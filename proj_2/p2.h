/**
 * Created by Gautam Ajey Khanapuri
 * 07 Feb 2026
 * Header file for Program Part 2. Abbreviated to p2.
 *
 *
 * USAGE EXAMPLES FOR P2 (Program Part 2)
 *
 * P2 matches a target image against a database using pre-computed feature vectors.
 * Three modes are available: BASIC, CLASSIC, and DNN.
 *
 * MODE 1: BASIC (-b-)
 * Uses 7x7 center square baseline matching with SSD distance.
 *
 * Format: ./p2 <target_image> -b-<metric> <baseline_csv>
 *
 * Example:
 *   ./p2 query.jpg -b-i baseline_ft_vec_12345.csv
 *
 * Where:
 *   - query.jpg: target image to match
 *   - -b-: BASIC mode flag
 *   - i: SSD distance metric
 *   - baseline_ft_vec_12345.csv: CSV with 7x7 square vectors from P1
 *
 * Output: Top N images ranked by similarity to query.jpg
 *
 * MODE 2: CLASSIC (-m-)
 * Uses multiple histograms with weighted combination of distance metrics.
 * Each part has its own histogram type, distance metric, and weight.
 *
 * Format: ./p2 <target_image> -m-<spec> <csv1> <csv2> ...
 *
 * Spec format (groups of 4 characters):
 *   [part][histogram][metric][weight][part][histogram][metric][weight]...
 *
 * Part codes:
 *   w=whole, t=top, T=bottom, l=left, L=right, a/A/b/B=quadrants, c=center, C=edge
 *
 * Histogram codes:
 *   B=baseline, r=RG, R=RGB, h=HS, u=intensity, s=sobel_mag_1d, S=sobel_mag_2d, g=GLCM, G=Laws
 *
 * Distance metric codes:
 *   i=SSD, I=intersection, q=chi-squared, Q=earth_mover, o=cosine, O=correlation,
 *   y=bhattacharyya, Y=manhattan, p=custom_perceptual, P=custom_weighted
 *
 * Weight codes:
 *   1-9 (digit representing relative importance, will be normalized)
 *
 * Example 1 - Simple two-part matching:
 *   ./p2 sunset.jpg -m-trI3TrI1 top_rg_multi_*.csv bottom_rg_multi_*.csv
 *
 *   Breakdown:
 *     trI3 = top half + RG histogram + intersection + weight 3
 *     TrI1 = bottom half + RG histogram + intersection + weight 1
 *
 *   Meaning: Match using top RG (75% weight) and bottom RG (25% weight)
 *
 * Example 2 - Complex multi-feature matching:
 *   ./p2 dog.jpg -m-wri2wSO1wGi1 whole_rg_*.csv whole_sobel_*.csv whole_law_*.csv
 *
 *   Breakdown:
 *     wri2 = whole + RG + SSD + weight 2
 *     wSO1 = whole + sobel_mag_2d + correlation + weight 1
 *     wGi1 = whole + Laws + SSD + weight 1
 *
 *   Meaning: Combine color (50%), texture-orientation (25%), and Laws texture (25%)
 *
 * Example 3 - Spatial weighting:
 *   ./p2 face.jpg -m-crq3Tri1 center_rg_*.csv bottom_rg_*.csv
 *
 *   Breakdown:
 *     crq3 = center + RG + chi-squared + weight 3
 *     Tri1 = bottom + RG + SSD + weight 1
 *
 *   Meaning: Emphasize center region (face) over background
 *
 * MODE 3: DNN (-d-)
 * Uses pre-computed DNN embeddings with single distance metric.
 * Target must be a CSV file where first entry is the target image and its embedding.
 *
 * Format: ./p2 <target_csv> -d-<metric> <embeddings_csv>
 *
 * Example:
 *   ./p2 target_embedding.csv -d-o dnn_embeddings_database.csv
 *
 * Where:
 *   - target_embedding.csv: CSV with one line containing target image and embedding
 *   - -d-: DNN mode flag
 *   - o: cosine similarity metric (common for embeddings)
 *   - dnn_embeddings_database.csv: CSV with all database embeddings
 *
 * Target CSV format:
 *   target_image.jpg,0.123,0.456,0.789,...,0.321
 *
 * Common metrics for DNN:
 *   o (cosine): Most common for deep learning embeddings
 *   O (correlation): Good for semantic similarity
 *   i (SSD): Direct distance in embedding space
 *
 * GENERAL NOTES
 *
 * All modes return results sorted by distance (lower = more similar).
 *
 * CSV files must be generated by P1 first:
 *   ./p1 -m-<spec> <image_directory>
 *   (generates feature CSVs that P2 reads)
 *
 * Number of CSV files provided to P2 must match number of parts in spec AND must be in the same order.
 *
 * Weights in CLASSIC mode are automatically normalized (don't need to sum to any value).
 *
 * Interactive output: Shows top 5 automatically, then prompts for more.
 */

#ifndef P2_H
#define P2_H

#include <iostream>
#include <string>
#include <cstdlib>
#include <filesystem>
#include <map>
#include <set>
#include <functional>
#include <cctype>
#include <iomanip>

#include "utils.h"
#include "dist_utils.h"

namespace fs = std::filesystem;

/**
 * Function pointer types for the P2 class function maps.
 * These allow dynamic dispatch based on mode without if-else chains.
 */
typedef std::function<int()> RunnerFunc;                                              // Executes matching algorithm
typedef std::function<int(std::vector<std::string>& files)> SpecValidatorFunc;        // Validates specification string
typedef std::function<int(const std::string&)> TargetPathValidatorFunc;               // Validates target file path

/**
 * Operating modes for the matching program.
 */
enum Mode {
    BASIC,    // b - baseline 7x7 square matching
    CLASSIC,  // m - multiple histogram matching with custom features
    DNN       // d - deep neural network embedding matching
};

/**
 * Maps mode characters to Mode enum values.
 * Used for parsing command line arguments.
 */
const std::map<char, Mode> str_to_mode = {
    {'b', BASIC},
    {'m', CLASSIC},
    {'d', DNN},
};

const int top_n = 5;  // Default number of top matches to display before prompting user

// Allowed image file extensions for target images
inline const std::set<std::string>& allowed_img_formats = {".jpg", ".jpeg", ".jpe", ".png", ".webp", ".tiff", ".tif", ""};
const std::string op_file_format = ".csv";  // Output file format

/**
 * Main class for Program Part 2.
 * Loads target image, reads pre-computed feature vectors, computes distances,
 * and returns ranked list of similar images.
 */
class P2 {
    private:
        fs::path tgt_path;                                    // Path to target image or CSV
        Mode mode;                                            // Operating mode (BASIC, CLASSIC, or DNN)
        std::string spec;                                     // Specification string from command line
        std::vector<fs::path> vec_files;                      // Paths to feature vector CSV files
        std::vector<std::pair<double, fs::path>> neighbours;  // Results: (distance, image_path) pairs

    public:
        /**
         * Default constructor. Initializes mode to CLASSIC.
         */
        P2() {mode = CLASSIC;}

        /**
         * Validates target path for CLASSIC mode.
         * Target must be a valid image file.
         *
         * @param arg target file path string from command line
         * @return 0 if valid, exits otherwise
         */
        int validate_tgt_path_classic(const std::string& arg);

        /**
         * Validates target path for DNN mode.
         * Target must be a CSV file containing single target entry.
         *
         * @param arg target file path string from command line
         * @return 0 if valid, exits otherwise
         */
        int validate_tgt_path_dnn(const std::string& arg);

        /**
         * Dispatches to appropriate target path validator based on current mode.
         *
         * @param arg target file path string from command line
         * @return 0 if valid, exits otherwise
         */
        int validate_tgt_path(const std::string& arg);

        /**
         * Parses mode flag from command line argument.
         * Expected format: -m-spec or -d-spec
         *
         * @param arg mode argument string from command line
         * @return 0 if valid, exits otherwise
         */
        int parse_mode(const std::string& arg);

        /**
         * Validates specification for BASIC mode.
         * Expects single CSV file with baseline features.
         *
         * @param files vector of feature file paths
         * @return 0 if valid, exits otherwise
         */
        int validate_basic_spec(std::vector<std::string>& files);

        /**
         * Validates specification for CLASSIC mode.
         * Checks that spec length matches number of files and format is correct.
         * Each config group has 4 chars: part + histogram + metric + weight.
         *
         * @param files vector of feature file paths
         * @return 0 if valid, exits otherwise
         */
        int validate_classic_spec(std::vector<std::string>& files);

        /**
         * Validates specification for DNN mode.
         * Expects single character (distance metric) and single CSV file.
         *
         * @param files vector of feature file paths
         * @return 0 if valid, exits otherwise
         */
        int validate_dnn_spec(std::vector<std::string>& files);

        /**
         * Dispatches to appropriate spec validator based on current mode.
         *
         * @param files vector of feature file paths from command line
         * @return 0 if valid, exits otherwise
         */
        int validate_spec(std::vector<std::string>& files);

        /**
         * Executes baseline matching using 7x7 center square and SSD.
         *
         * @return 0 if successful
         */
        int run_basic();

        /**
         * Executes CLASSIC matching using multiple histograms with weighted combination.
         * Creates Distance object which handles feature loading and comparison.
         *
         * @return 0 if successful
         */
        int run_classic();

        /**
         * Executes DNN embedding matching using specified distance metric.
         * Creates MyDNN object which handles embedding comparison.
         *
         * @return 0 if successful
         */
        int run_dne();

        /**
         * Dispatches to appropriate runner based on current mode.
         * Displays results with interactive prompting.
         *
         * @return 0 if successful
         */
        int run();

        /**
         * Function map for dispatching to appropriate runner based on mode.
         * Uses lambda captures to call member functions.
         */
        const std::map<Mode, RunnerFunc> runners = {
            {BASIC, [this] () {return run_basic();}},
            {CLASSIC, [this] () {return run_classic();} },
            {DNN, [this] () {return run_dne();} }
        };

        /**
         * Function map for dispatching to appropriate spec validator based on mode.
         */
        const std::map<Mode, SpecValidatorFunc> spec_validators = {
            {BASIC, [this] (auto& p) {return validate_basic_spec(p);}},
            {CLASSIC, [this] (auto& p) {return validate_classic_spec(p);}},
            {DNN, [this] (auto& p) {return validate_dnn_spec(p);}}
        };

        /**
         * Function map for dispatching to appropriate target path validator based on mode.
         */
        const std::map<Mode, TargetPathValidatorFunc> target_path_validators = {
            {BASIC, [this] (const std::string& arg) {return validate_tgt_path_classic(arg);}},
            {CLASSIC, [this] (const std::string& arg) {return validate_tgt_path_classic(arg);}},
            {DNN, [this] (const std::string& arg) {return validate_tgt_path_dnn(arg);}}
        };
};


#endif //P2_H
